Review

[1] What is the purpose of working on the program after the first version works? Give a list of reasons.
The initial working Version is about 50% finished
now we need to try and break the program

[2] Why does 1+2; q typed into the calculator not quit after it receives an error?
1+x= returns a "primary expected" error
because in main we have: 
if(t.kind='=')//instantly calls expression()
we should test for x AFTER testing for '='
assignment vs comparator
silent killer: always returns true if assignment

[3] Why did we choose to make a constant character called number?
makes the magic constant '8' a legible character that indicates it's purpose: a number identifier

[4] We split main() into two separate functions. What does the new function do and why did we split main()?
general scaffolding (start/end the program, handle fatal errors)
handle calculation loop

[5] Why do we split code into multiple functions? State principles.
ideally a function performs a single logical action
structure is more directly reflected in code and easier to understand.

[6] What is the purpose of commenting?
it helps remind the author or reader the purpose of the code
always check on rereading if: comments are still valid, adequate for a reader, not distracting

[7] What is the use of symbolic constants?
it helps the definition of the value make sense every time in the context it is calles

[8] Why do we care about code layout?
it helps prevent bugs and makes it harder for them to hide in plain sight

[9] How do we handle % (remainder) of floating-point numbers?
x%y==xâˆ’y*int(x/y) or fmod()
0 for y would return an error for division by zero

[10] What does is_declared() do and how does it work?
checks names vector iteratively 

[11] The input representation for let is more than one character. How is it accepted as a single token in the modified code?
let is a name followed by an expression -> store it in var_table
'L' is the representation of the "let" token, with "let" as our keyword, which we compare to s in const string declkey
we need to do lookahead

[12] What are the rules for what names can and cannot be in a calculator program?
check whether there already is a Variable called var in var_table
add (var,val) to var_table
c++ naming convention applies.

[13] Why is it a good idea to build a program incrementally?
Because it follows the Divide and conquer strathegy

[14] When do you start to test?
You should start testing as soon as a functional program exists (iterate)

[15] When do you retest?
Every time a new functionality is implemented (compiles, outputs and handles errors)

[16] How do you decide what should be a separate function?
a function should return one output for given parameters

[17] How do you choose names for variables and functions? List possible reasons.
Make them relate to their sematic purpose, so they are legible in code:
void circumference(int radius)
principle of least astonishment: should be 

[18] What should be in comments and what should not?
they are for things that code expresses poorly. 
-Intent
-grammar (epxressions and tokens) ->documentation

[19] When do we consider a program finished?
when the initial design goals have been met, bugs are resonable handled and it is possible to return to this project and build onto it in the future.

