[1] What is the difference between a declaration and a definition?
A declaration is a statement that inctroduces a name into a scope. (interface)
	Specifying a type for what is named
	optionally specifying an initializer
	Types of declarations:
		-Variables and constants
		-Functions
		-Namespaces
		-Modules
		-Types (classes and enumerations)
		-Templates
		-Concepts
A definition is a fully specified entity declaration (implementation)
	Sets aside memory
	
[2] How do we syntactically distinguish between a function declaration and a function definition?
A function declaration would be a function without its body

[3] How do we syntactically distinguish between a variable declaration and a variable definition?
A variable declaration would be without assigning the variables value. So in the form:
type name; instead of type name = value; AND you need to use the keyword extern int a;

[4] Why canâ€™t you use the functions in the calculator program from Chapter 5 without declaring one or more of them first?
	Because these functions haven't been declared yet. 
	We first need to define the interfacs to useful facilities to the compiler (usually in the header file)

[5] Is int a; a definition or just a declaration?
This is just a declaration
There is no memory set aside for it yet

[6] Why is it a good idea to initialize variables as they are declared?
because if we end up using the variable before assigning a value it will lead to undefined behaviour [CG: ES.20]
Only defining a variable without initialization should be the exception, not the norm in C++ (no default value, except in the case of string or vector, thanks to the default constructor)

[7] What can a function declaration consist of?
functions are used in C++ to name and represent computations and actions
A function declaration consists of:
	return type (void if we don't want to return a value)
	name
	list of parameters in parentheses (formal arguments)

[8] What is the suffix return type notation, and why might you use it? (trailing notation)
sometimes it's more legible, especially when return names become longer
instead of 	type-identifier function-identifier (parameter-list) 
we write:	auto function-identifier (parameter-list) -> type-identifier

[9] What good does indentation do?
Makes nesting apparent

[10] What is the scope of a declaration?
	scope is a region of program text. A name is declared in scope and valid from the point of it's declaration until the end of the scope in which it was declared (e.g. int main(){}
	purpose: keep names local, so they don't interfere with names declared elsewhere
	two incompatible declarations in the same scope are reffered to as a "clash"
	side note: extern keyword states that the following declaration isn't a definition (can be overused for too many global variables) it simply tells us how we can use a name without allocating memory or a function body. using this keyword you can declare as many times as you want
	Every name has to be declared before it is used (except for class members), so sometimes it is necessary to "forward" declare a function in the case of cyclic call chains


[11] What kinds of scope are there? Give an example of each.
There are:
global scope		area of text outside of any other scope 
module scope		area of text within a module
namespace scope		a named scope nexted in the global scope or in another namespace
class scope		area of text within a class
local scope		between {...} braces of a block or in a function argument list
statement scope		e.g. in a for-statement

[12] What is the difference between a class scope and local scope?
The class scope is a local scope within the class body, creating a nested (local) scope
access: a private variable is still in class scope meaning all member functions (public or prvate) can see and use it

class MyClass { // <--- Class Scope starts here
    int m_a;    // Defined in Class Scope (visible to everything below)

public:
    MyClass() { // <--- Constructor (Local Scope starts)
        m_a = 5; // Valid: m_a is in Class Scope, so Constructor can see it
        int x = 0; // x is in Constructor's Local Scope
    } // <--- Constructor Scope ends (x dies here)

    void print() {
        // m_a is STILL visible here because it's in Class Scope
        // x is NOT visible here
    }
}; // <--- Class Scope ends here

[13] Why should a programmer minimize the number of global variables?
in order to keep the number and scope of all named entities manageable, one must adhere to locality. Otherwise the declarations clash
Another problem is that we don't know which functions modify our global variables
(variables initalized in this manner exist until the porgram terminates so its memory is always occupied)
global variables that aren't initialized as a constant expression are a major pitfall
static local variables: initializes the first time its read, it can be expensive for the compiler to construct a global function: const Date& today(){static const=... return..}

[14] What is the difference between pass-by-value and pass-by-reference?
functions usually need arguments and often return a result
The way these arguments are specified and passed:
-pass by value:
	gives the function a copy of the value you use as the argument (cost of copying)
-pass by reference: &name
	gives the function the address/reference of the object in memory to be modified
	can be aconvenient shorthand for some object
A general rule of thumb
1. Use pass-by-value for very small objects (e.g. two doubles)
2. Use pass-by-const-reference to pass large objects you don't need to modify
3. return a result rather than modifying an object through a reference argument
4. Use pass-by-reference only when you have to

[15] What is the difference between pass-by-reference and pass-by-const-reference?
-pass-by-const-reference:
	stops the function from modifying its argument by accident (e.g. we only want to write a print() or my_find() function, because copies are unnecessary)
	This can be used if we only want to read the value and not write to it's address
	when calling the function foo(x,y,z) and y is pass by reference, it must be a variable, while pass by reference const can be a literal value when calling

[16] What is a swap()?
A standard library function that exchanges the value of two variables. This is done in in a pass-by-reference manner. A temporary variable is necessary for the exchange to work (otherwise we'd delete data during the swap)

[17] Would you ever define a function with a vector<double> as a by-value parameter?
yes, for example if we want to modify the data in the entire vector and we need to iter ate over its elements (manipulating containers, functions that change several objects)


[18] Give an example of undefined order of evaluation. Why can undefined order of evaluation be a problem?
a thread of execution reaches statements and proceeds through them according to the language rules
example definition of a variable: constructed (memory set aside and object initalized)
when the variable goes out of scope the object it refers to is in principle removed and the compiler can use its memory for something else
As a rule of thumb, to avoid complicated expressions: if we change the value of a variable in an expression, we don't read or write the variable twice in that same expression
The order of the calling function (if its not commutative like matrix multiplication) will fail or provide different results

[19] What do x&&y and x||y, respectively, mean?
&& logical AND 
|| logical OR
short circuit evaluation: 
((left-hand of && false -> return false))
((right-hand of || true -> return true))

[20] Which of the following is standard-conforming C++: functions within functions, functions within classes, classes within classes, classes within functions?
side note: local functions are not legal in C++, use lambdas instead
member classes are most common and useful in complicated classes

[21] What goes into an activation record?
when a function is called, this data structure is set aside with a copy of all its parameters and local variables
varies from implementation
information that the function needs to return to its caller and and to return a value
it's a stack to tell the compiler what we need to set aside memory for
every call of a function gets its own activation record
Every time we enter a block the variables in its local scope are constructed and by the end of the scope (say a loop) destroyed in *reverse* order of construction. The compiler will have astack frame for the variables that will be reused repeatedly

[22] What is a call stack and why do we need one?
whenever we call a function the stack of activation records grows by one record LIFO principle, just like chain links in YuGiOh
A constexpr function  behaves just like an ordinary fuction until you use it where a constant is needed
Then it is calculated at compile time and its arguemnts must be constant expressions (or it returns an error) it cannot have side effects (it cannot change the value of objects outside its local scope) (because they don't exist at compile time)
if a function should only be evaluated at compile-time, declare as consteval

[23] What is the purpose of a namespace?
organizing named identifier for parts of our program without defining a type, it helps the names not interfering with each other between namespaces

[24] How does a namespace differ from a class?
if someone was to use both libraries (classes) of the same global namespace they would be clashing if they had the same name for certain functions A namespace/class is combined with '::' and is called a fully qualified name
Class defines a 	TYPE - can create objects of that type
namespace defines a	SCOPE - named bucket for names, not an object

[25] What is a using declaration?
instead of reffering to ecery function by its fully qualified name, we can make "shorthands" with the using directive
using namespace std; 	using directive (directs compiler:: look at the whole namespace)
using std::string;	using declaration (declares this one specific name valid here)

[26] Why should you avoid using directives in a header?
because one can lose track which names come from where

[27] What is namespace std?
The C++ standard library directive 

Modules and Headers:
header: an established mechanism for composing programs out of files #include simply copies the declarations from the header file (preprocessing). Therefore it should only contain declarations that can be duplicated (function declarations, class definitions and numeric constants)
module:	modern language mechanism for directly expressing modularity, to compile and use them the specific C++ implementation must be known (https://www.stroustrup.com/module_use.html) but implementation is faster than its alternatives
module example;

//implementation details
import std;	//a module can import the modules it needs
export class { 	//available for users that import the module
public:
};
void x{}
